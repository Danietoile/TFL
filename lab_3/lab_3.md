# Лабораторная работа 3

## 1. Определение языка

$$L = \{w_1\, a^n\, w_2 \mid (|w_1| = n \lor |w_2| < n)\ \&\ w_i \in \{a, b\}^*\}$$

Алфавит: $\Sigma = \{a, b\}$.

Строка $s \in \{a,b\}^*$ принадлежит $L$, если существует разбиение $s = w_1\, a^n\, w_2$, где $n \geq 1$, $w_1, w_2 \in \{a,b\}^*$, и выполняется хотя бы одно из условий:

- **Условие 1:** $|w_1| = n$ (длина левой части равна длине блока из $a$),
- **Условие 2:** $|w_2| < n$ (длина правой части строго меньше длины блока из $a$).

> **Замечание о $n \geq 1$:** Если допустить $n = 0$, то $a^0 = \varepsilon$, и условие $|w_1| = 0$ выполняется при $w_1 = \varepsilon$, что делает язык тривиально равным $\{a,b\}^*$. Далее предполагаем $n \geq 1$.

---

## 2. Представление языка как объединения

Представим $L = L_1 \cup L_2$, где:

$$L_1 = \{w_1\, a^n\, w_2 : |w_1| = n,\ n \geq 1,\ w_1, w_2 \in \{a,b\}^*\}$$
$$L_2 = \{w_1\, a^n\, w_2 : |w_2| < n,\ n \geq 1,\ w_1, w_2 \in \{a,b\}^*\}$$

### 2.1. Характеризация $L_1$

Строка $s$ длины $m$ принадлежит $L_1$ тогда и только тогда, когда существует $n \geq 1$ такое, что символы $s$ на позициях $n, n+1, \ldots, 2n-1$ (0-индексация) — все равны $a$.

Иными словами: в строке существует непрерывный блок из $n$ букв $a$, начинающийся ровно на позиции $n$.

**Примеры:**
- $n=1$: позиция 1 — это $a$. Значит, любая строка длины $\geq 2$ со второй буквой $a$ лежит в $L_1$.
- $n=2$: позиции 2 и 3 — обе $a$.
- $n=3$: позиции 3, 4, 5 — все $a$.

### 2.2. Характеризация $L_2$

Строка $s$ длины $m$ принадлежит $L_2$ тогда и только тогда, когда существует непрерывный блок из $n$ букв $a$ (начинающийся на позиции $i$) такой, что суффикс после блока имеет длину $m - i - n < n$.

**Ключевое наблюдение:** Если строка **оканчивается** на $a$, то, взяв последнюю букву $a$ как блок $a^1$ и $w_2 = \varepsilon$, получаем $|w_2| = 0 < 1 = n$. Следовательно, **любая строка, оканчивающаяся на $a$, лежит в $L_2$**.

Более того, если ближе к концу строки есть достаточно длинный блок из $a$, а после него осталось мало символов — строка тоже в $L_2$.

### 2.3. Какие строки НЕ входят в $L$?

Строка $s \notin L$ тогда и только тогда, когда для **всех** допустимых разложений $s = w_1 a^n w_2$ (с $n \geq 1$) выполнено:
- $|w_1| \neq n$ **И** $|w_2| \geq n$.

**Необходимые условия для $s \notin L$:**
1. $s$ не оканчивается на $a$ (иначе $s \in L_2$), то есть $s$ оканчивается на $b$ (или $s = \varepsilon$).
2. Второй символ $s$ (позиция 1) не равен $a$ (иначе при $n=1$ получаем $|w_1| = 1 = n$, и $s \in L_1$).

**Примеры строк вне $L$:**
| Строка | Проверка |
|--------|----------|
| $\varepsilon$ | Нет разложения с $n \geq 1$ |
| $b$ | Нет букв $a$ |
| $ab$ | Единственный блок: $n=1, i=0$. $\|w_1\|=0 \neq 1$, $\|w_2\|=1 \not< 1$ |
| $abb$ | $n=1, i=0$: $\|w_1\|=0 \neq 1$, $\|w_2\|=2 \not< 1$ |
| $bb$ | Нет букв $a$ |
| $abab$ | Позиция 1 = $b$. Блоки: $a$ на поз. 0 ($\|w_2\|=3 \geq 1$), $a$ на поз. 2 ($\|w_1\|=2 \neq 1$, $\|w_2\|=1 \geq 1$) |

**Примеры строк в $L$:**
| Строка | Обоснование |
|--------|-------------|
| $a$ | $n=1$, $w_1=\varepsilon$, $w_2=\varepsilon$, $\|w_2\|=0<1$ — $L_2$ |
| $ba$ | $n=1$, $w_1=b$, $w_2=\varepsilon$, $\|w_1\|=1=n$ — $L_1$ |
| $aa$ | $n=1$, $w_1=a$, $\|w_1\|=1=n$ — $L_1$ |
| $aab$ | $n=1$, $w_1=a$, $\|w_1\|=1=n$ — $L_1$ |
| $bba$ | $n=1$, $w_2=\varepsilon$, $\|w_2\|=0<1$ — $L_2$ |
| $abba$ | $n=1$, блок $a$ на поз. 3: $\|w_2\|=0<1$ — $L_2$ |

---

## 3. Анализ на детерминизм

### 3.1. Язык $L$ является КС-языком (CFL)

Оба языка $L_1$ и $L_2$ являются контекстно-свободными (построим грамматики ниже), а класс КС-языков замкнут относительно объединения. Значит, $L = L_1 \cup L_2$ — КС-язык.

### 3.2. Язык $L$ является недетерминированным КС-языком

**Утверждение:** $L$ не является детерминированным КС-языком (ДКСЛ / DCFL).

**Обоснование:**

Для распознавания строки из $L$ автомат должен:
1. **Угадать** положение начала блока $a^n$ (позицию $i$) и его длину $n$.
2. **Угадать**, какое из двух условий ($|w_1|=n$ или $|w_2|<n$) проверять.
3. Использовать стек для сравнения длин ($|w_1|$ с $n$, или $|w_2|$ с $n$).

Ни одно из этих решений не может быть принято детерминированно при чтении слева направо, поскольку:

- Блок $a^n$ может начинаться в произвольном месте строки, и отличить буквы $a$ из $w_1$ от букв $a$ из блока $a^n$ невозможно без «угадывания».
- Проверка условия $|w_1| = n$ требует подсчёта символов до начала блока и сравнения с длиной блока, а проверка $|w_2| < n$ — подсчёта символов после блока. Детерминированный автомат не может заранее знать, какое условие приведёт к успеху.

Формально покажем, что дополнение $\overline{L}$ не является контекстно-свободным, что доказывает недетерминированность $L$ (поскольку DCFL замкнуты относительно дополнения).

Рассмотрим пересечение $\overline{L}$ с регулярным языком $b^* a^* b^*$:

$$\overline{L} \cap b^* a^* b^* = \{b^i a^j b^k : j < i\ \text{и}\ j \leq k\} \cup \{b^i b^k : i,k \geq 0\}$$

(строки без $a$ тривиально не в $L$; строки $b^i a^j b^k$ не в $L$ тогда и только тогда, когда $j < i$ и $j \leq k$, что было показано в разделе 2.)

Рассмотрим подъязык $L' = \{b^i a^j b^j : j < i\}$ — пересечение $\overline{L} \cap b^*a^*b^*$ с регулярным языком $\{b^i a^j b^k : i \geq 1\} \cap \{w : \text{количество } a = \text{количество } b \text{ после } a\text{-блока}\}$... 

Применим лемму о накачке для КС-языков к $L' = \{b^i a^j b^j : j < i\}$. Допустим, $L'$ — КС-язык с константой накачки $p$. Возьмём строку $s = b^{p+1} a^p b^p \in L'$ (так как $p < p+1$).

По лемме о накачке, $s = uvxyz$, где $|vxy| \leq p$, $|vy| \geq 1$, и $u v^k x y^k z \in L'$ для всех $k \geq 0$.

**Случай 1:** $vxy$ целиком внутри $b^{p+1}$. Тогда $v$ и $y$ содержат только $b$ из первого блока. При $k = 0$ убираем $|vy|$ букв $b$: получаем $b^{p+1-|vy|} a^p b^p$. Нужно $p < p+1-|vy|$, т.е. $|vy| < 1$. Но $|vy| \geq 1$ — противоречие.

**Случай 2:** $vxy$ целиком внутри $a^p$. При $k = 0$: $b^{p+1} a^{p-|vy|} b^p$. Нужно $p-|vy| = p$ (для $j = k$), но $|vy| \geq 1$ — количество $a$ уменьшилось, а количество $b$ в конце осталось $p$, значит $j \neq k$. Нарушение $j = k$ (количество $a$ ≠ количество конечных $b$). При $k = 2$: $b^{p+1} a^{p+|vy|} b^p$. Нужно $p+|vy| = p$ — невозможно.

**Случай 3:** $vxy$ целиком внутри последнего $b^p$. Аналогично: при $k=0$ получаем $b^{p+1} a^p b^{p-|vy|}$. Нужно $p = p-|vy|$ — невозможно.

**Случай 4:** $vxy$ пересекает границу $b^{p+1}$ и $a^p$. Тогда $v$ содержит $b$, $y$ содержит $a$ (или наоборот). При $k = 2$: увеличиваем и $b$ в первом блоке, и $a$ — число $a$ растёт, но число $b$ в конце остаётся $p$. Получаем $j' > p = k$ — нарушение $j \leq k$... Но также нужно проверить $j = k$: если $v = b^r$, $y = a^t$, то при $k=2$ имеем $j = p+t$, $k = p$ (последние $b$ не тронуты), $j \neq k$.

**Случай 5:** $vxy$ пересекает границу $a^p$ и $b^p$. Тогда $v$ содержит $a$, $y$ содержит $b$ из последнего блока (или наоборот). При $k=0$: и $a$, и конечные $b$ уменьшаются. $j' = p - |v \cap a|$, $k' = p - |y \cap b|$. Нужно $j' = k'$, т.е. $|v \cap a| = |y \cap b|$. Это возможно только если уменьшение одинаковое, но также нужно $j' < i = p+1$, т.е. $p - |v \cap a| < p+1$ — выполнено. При $k = 2$: $j' = p + |v \cap a|$, $k' = p + |y \cap b|$, нужно $j' = k'$, т.е. $|v \cap a| = |y \cap b|$. И нужно $j' < p+1$, т.е. $p + |v \cap a| < p+1$, т.е. $|v \cap a| < 1$, значит $|v \cap a| = 0$, но тогда $v$ не содержит $a$, а $v$ — на границе... Значит $v$ полностью из $a$, и тогда $|v \cap a| = |v| \geq 1$. Противоречие: $|v| < 1$.

Таким образом, **ни одно разбиение** не позволяет накачивать, значит $L'$ не является КС-языком. Но $L'$ получается из $\overline{L}$ пересечением с регулярным языком. Если бы $\overline{L}$ был КС-языком, то и $L'$ был бы КС-языком (КС ∩ REG = КС). Противоречие.

Следовательно, $\overline{L}$ — **не КС-язык**, а значит, $L$ — **не DCFL** (так как дополнение DCFL всегда DCFL, а DCFL ⊂ CFL, и если бы $L$ был DCFL, то $\overline{L}$ тоже был бы DCFL ⊂ CFL).

> **Вывод:** $L$ — **недетерминированный контекстно-свободный язык**.

---

## 4. Контекстно-свободная грамматика

### 4.1. Грамматика для $L_1$

$L_1 = \{w_1\, a^n\, w_2 : |w_1| = n,\ n \geq 1\}$

Нетерминал $T$ порождает строки вида $w_1 a^{|w_1|}$, где $|w_1| \geq 1$:

$$T \to a\,T\,a \mid b\,T\,a \mid a\,a \mid b\,a$$

Проверка: $T \Rightarrow ba$ — это $w_1 = b$, $a^1$, $|w_1| = 1 = n$. ✓  
$T \Rightarrow a\,T\,a \Rightarrow a\,b\,a\,a$ — это $w_1 = ab$, $a^2$, $|w_1| = 2 = n$. ✓

Нетерминал $R$ порождает $\{a,b\}^*$:

$$R \to a\,R \mid b\,R \mid \varepsilon$$

Грамматика для $L_1$: $S_1 \to T\,R$

### 4.2. Грамматика для $L_2$

$L_2 = \{w_1\, a^n\, w_2 : |w_2| < n,\ n \geq 1\}$

Перепишем условие: $n > |w_2|$, т.е. $n = |w_2| + k$, $k \geq 1$.

Тогда $w_1\, a^n\, w_2 = w_1 \cdot a^k \cdot a^{|w_2|}\, w_2$, где $a^k$ — «лишние» буквы $a$.

Нетерминал $U$ порождает строки вида $a^{|w_2|}\, w_2$, где $w_2 \in \{a,b\}^*$:

$$U \to a\,U\,a \mid a\,U\,b \mid \varepsilon$$

Проверка: $U \Rightarrow \varepsilon$ — $w_2 = \varepsilon$, $a^0 = \varepsilon$. ✓  
$U \Rightarrow a\,U\,b \Rightarrow a\,b$ — $w_2 = b$, $a^1 b$, $|w_2| = 1$. ✓  
$U \Rightarrow a\,U\,a \Rightarrow a\,a\,U\,b\,a \Rightarrow a\,a\,b\,a$ — $w_2 = ba$, $a^2 ba$, $|w_2| = 2$. ✓

Нетерминал $A$ порождает $a^+$ (минимум одна $a$ — это «лишние» буквы):

$$A \to a\,A \mid a$$

Нетерминал $Q$ порождает $w_1 \cdot a^k = \{a,b\}^*\, a^+$, т.е. любую непустую строку, оканчивающуюся на $a$:

$$Q \to a\,Q \mid b\,Q \mid a$$

(Или эквивалентно: $Q = R \cdot A$, но компактнее записать одним нетерминалом.)

Грамматика для $L_2$: $S_2 \to Q\,U$

### 4.3. Полная грамматика для $L$

$$G = (\{S, S_1, S_2, T, R, Q, U\},\ \{a, b\},\ P,\ S)$$

Правила $P$:

| № | Правило |
|---|---------|
| 1 | $S \to S_1$ |
| 2 | $S \to S_2$ |
| 3 | $S_1 \to T\,R$ |
| 4 | $S_2 \to Q\,U$ |
| 5 | $T \to a\,T\,a$ |
| 6 | $T \to b\,T\,a$ |
| 7 | $T \to a\,a$ |
| 8 | $T \to b\,a$ |
| 9 | $R \to a\,R$ |
| 10 | $R \to b\,R$ |
| 11 | $R \to \varepsilon$ |
| 12 | $Q \to a\,Q$ |
| 13 | $Q \to b\,Q$ |
| 14 | $Q \to a$ |
| 15 | $U \to a\,U\,a$ |
| 16 | $U \to a\,U\,b$ |
| 17 | $U \to \varepsilon$ |

### 4.4. Проверка грамматики на примерах

**Строка $a$ (ожидаем: $\in L$):**  
$S \Rightarrow S_2 \Rightarrow Q\,U \Rightarrow a\,U \Rightarrow a\,\varepsilon = a$ ✓  
(Здесь $w_1 = \varepsilon$, $a^1$, $w_2 = \varepsilon$, $|w_2| = 0 < 1$.)

**Строка $ba$ (ожидаем: $\in L$):**  
$S \Rightarrow S_1 \Rightarrow T\,R \Rightarrow b\,a \cdot \varepsilon = ba$ ✓  
($w_1 = b$, $a^1$, $w_2 = \varepsilon$, $|w_1| = 1 = n$.)

**Строка $aab$ (ожидаем: $\in L$):**  
$S \Rightarrow S_1 \Rightarrow T\,R \Rightarrow a\,a \cdot R \Rightarrow a\,a\,b\,R \Rightarrow a\,a\,b = aab$ ✓  
($w_1 = a$, $a^1$, $w_2 = b$, $|w_1| = 1 = n$.)

**Строка $abba$ (ожидаем: $\in L$):**  
$S \Rightarrow S_2 \Rightarrow Q\,U \Rightarrow b\,Q\,U \Rightarrow b\,a\,U \Rightarrow b\,a\,a\,U\,a \Rightarrow b\,a\,a\,\varepsilon\,a = baaa$  
Не то. Попробуем иначе:  
$S \Rightarrow S_2 \Rightarrow Q\,U$. Нужно $Q\,U = abba$.  
$Q = a$, $U = bba$? $U$ начинается с $a$, а $bba$ начинается с $b$ — не подходит.  
$Q = ab$? $Q \Rightarrow a\,Q \Rightarrow a\,b\,Q$... но $Q$ должен оканчиваться на $a$: $Q \to a$.  
Не получается... Проверим через $L_2$: $s = abba$, блок $a$ на позиции 3 (последняя буква), $n=1$, $w_2 = \varepsilon$, $|w_2| = 0 < 1$.  
Тогда $w_1 = abb$, $a^1$, $w_2 = \varepsilon$. В грамматике: $Q$ порождает $w_1 a^k$ где $k \geq 1$: $Q = abba$ (строка, заканчивающаяся на $a$). $U = \varepsilon$.  
$Q \Rightarrow a\,Q \Rightarrow a\,b\,Q \Rightarrow a\,b\,b\,Q \Rightarrow a\,b\,b\,a$. $U \Rightarrow \varepsilon$.  
$S \Rightarrow S_2 \Rightarrow Q\,U \Rightarrow abba \cdot \varepsilon = abba$ ✓

**Строка $ab$ (ожидаем: $\notin L$):**

Через $S_1 \to T\,R$: минимальные строки из $T$ — $aa$ и $ba$ (длина 2), а $R$ добавляет суффикс. Строки из $T R$: $aa\ldots$, $ba\ldots$, $a...a...$, $b...a...$. Строка $ab$ не может быть порождена из $T$ (ни одно правило не даёт $ab$ — $T$ всегда оканчивается на $a$, а $R$ добавляет после).  
$TR$: $T$ порождает строку, заканчивающуюся на $a$, а $R$ добавляет суффикс. Строка $ab$ как $T=a, R=b$? Но $T$ не порождает одиночную $a$ (минимум 2 символа). Как $T=ab$? $T$ всегда заканчивается на $a$, $ab$ заканчивается на $b$ — нет.

Через $S_2 \to Q\,U$: $Q$ заканчивается на $a$, $U$ начинается с $a$ или пуста. Если $U = \varepsilon$, то $Q = ab$ — но $Q$ заканчивается на $a$, а $ab$ на $b$. Если $U \neq \varepsilon$, то $U$ начинается с $a$: $Q = a, U = b$? Но $U$ не порождает $b$ ($U \to aUa \mid aUb \mid \varepsilon$ — всё начинается с $a$ или пусто). ✓ Строка $ab$ не порождается.

---

## 5. Построение МП-автомата (PDA)

Поскольку язык **недетерминированный**, строим **недетерминированный МП-автомат** (НМПА).

### 5.1. Идея

Автомат при чтении строки **недетерминированно** выбирает одну из двух стратегий:

**Стратегия 1 (проверка $|w_1| = n$):**
1. Читаем символы $w_1$ и кладём маркер в стек за каждый прочитанный символ.
2. В какой-то момент решаем, что начался блок $a^n$: теперь читаем только $a$ и снимаем маркеры со стека.
3. Когда стек опустошился (прочитано столько $a$, сколько было символов в $w_1$) — блок $a^n$ закончился.
4. Читаем оставшиеся символы $w_2$ (любые), допускаем.

**Стратегия 2 (проверка $|w_2| < n$):**
1. Читаем символы $w_1$ (любые), не используя стек.
2. В какой-то момент решаем, что начался блок $a^n$: читаем $a$ и кладём маркеры в стек.
3. Когда блок $a^n$ закончился, читаем символы $w_2$ и снимаем маркеры.
4. Когда вход закончился, проверяем, что стек **не пуст** (означает $|w_2| < n$).

### 5.2. Формальное определение

$$M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$$

где:

- $Q = \{q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7, q_f\}$
- $\Sigma = \{a, b\}$
- $\Gamma = \{Z_0, X\}$  ($Z_0$ — начальный символ стека, $X$ — рабочий маркер)
- $q_0$ — начальное состояние
- $Z_0$ — начальный символ стека
- $F = \{q_f\}$ — множество допускающих состояний

### 5.3. Таблица переходов

**Стратегия 1: проверка $|w_1| = n$**

| Состояние | Вход | Верх стека | Переход | Действие со стеком | Комментарий |
|-----------|------|------------|---------|-------------------|-------------|
| $q_0$ | $\varepsilon$ | $Z_0$ | $q_1$ | $Z_0$ | Выбираем стратегию 1 |
| $q_1$ | $a$ | $Z_0$ | $q_1$ | $X Z_0$ | Читаем $w_1$, пушим $X$ |
| $q_1$ | $b$ | $Z_0$ | $q_1$ | $X Z_0$ | Читаем $w_1$, пушим $X$ |
| $q_1$ | $a$ | $X$ | $q_1$ | $X X$ | Читаем $w_1$, пушим $X$ |
| $q_1$ | $b$ | $X$ | $q_1$ | $X X$ | Читаем $w_1$, пушим $X$ |
| $q_1$ | $a$ | $X$ | $q_2$ | $\varepsilon$ | Начали блок $a^n$: читаем $a$, попаем $X$ |
| $q_2$ | $a$ | $X$ | $q_2$ | $\varepsilon$ | Продолжаем блок $a^n$ |
| $q_2$ | $\varepsilon$ | $Z_0$ | $q_3$ | $Z_0$ | Стек опустел: $|w_1| = n$, переход к $w_2$ |
| $q_3$ | $a$ | любой | $q_3$ | без изменений | Читаем $w_2$ |
| $q_3$ | $b$ | любой | $q_3$ | без изменений | Читаем $w_2$ |
| $q_3$ | $\varepsilon$ | $Z_0$ | $q_f$ | $Z_0$ | Допускаем |

**Стратегия 2: проверка $|w_2| < n$**

| Состояние | Вход | Верх стека | Переход | Действие со стеком | Комментарий |
|-----------|------|------------|---------|-------------------|-------------|
| $q_0$ | $\varepsilon$ | $Z_0$ | $q_4$ | $Z_0$ | Выбираем стратегию 2 |
| $q_4$ | $a$ | любой | $q_4$ | без изменений | Читаем $w_1$ |
| $q_4$ | $b$ | любой | $q_4$ | без изменений | Читаем $w_1$ |
| $q_4$ | $a$ | $Z_0$ | $q_5$ | $X Z_0$ | Начали блок $a^n$: пушим $X$ |
| $q_5$ | $a$ | $X$ | $q_5$ | $X X$ | Продолжаем блок, пушим |
| $q_5$ | $\varepsilon$ | $X$ | $q_6$ | $X$ | Блок $a^n$ закончился, переход к $w_2$ |
| $q_6$ | $a$ | $X$ | $q_6$ | $\varepsilon$ | Читаем $w_2$, попаем $X$ |
| $q_6$ | $b$ | $X$ | $q_6$ | $\varepsilon$ | Читаем $w_2$, попаем $X$ |
| $q_6$ | $\varepsilon$ | $X$ | $q_f$ | $X$ | Вход кончился, стек не пуст ⟹ $|w_2|<n$. Допускаем |

### 5.4. Обоснование недетерминированных переходов

Каждый **недетерминированный переход** соответствует выбору автомата:

1. **$q_0 \to q_1$ vs $q_0 \to q_4$**: выбор стратегии (условие 1 или условие 2). Это **существенный** недетерминизм, так как стратегии используют стек по-разному (пуш при чтении $w_1$ vs пуш при чтении $a^n$).

2. **$q_1$: продолжать читать $w_1$ vs начать блок $a^n$**: при чтении $a$ в состоянии $q_1$ можно либо положить $X$ в стек (буква $a$ относится к $w_1$), либо снять $X$ (буква $a$ — начало блока $a^n$). Это **существенный** недетерминизм: вхождение 'a' может быть частью $w_1$ или частью $a^n$.

3. **$q_4$: продолжать читать $w_1$ vs начать блок $a^n$**: аналогичный существенный недетерминизм.

4. **$q_5 \to q_6$**: решение об окончании блока $a^n$. Также существенный, так как следующая $a$ может быть частью блока или частью $w_2$.

**Пример существенного недетерминизма (слово с общим префиксом):**

Рассмотрим строки $aab$ и $aaab$:
- $aab$: в стратегии 1, $w_1 = a, a^1, w_2 = b$. При чтении первой $a$ нужно пушить (это $w_1$), при чтении второй $a$ — попать (это $a^n$).
- $aaab$: в стратегии 1, $w_1 = a, a^1, w_2 = ab$. Или $w_1 = aa, a^2, w_2 = b$.

В обоих случаях после чтения первой $a$ автомат не знает, относится ли она к $w_1$ или к $a^n$, что делает недетерминизм существенным.

---

## 6. Анализ на беспрефиксность

Язык $L$ называется **беспрефиксным**, если для любых $x, y \in L$ с $x \neq y$ строка $x$ не является префиксом $y$.

**Утверждение:** $L$ **не является** беспрефиксным.

**Контрпример:**
- $a \in L$ (так как $n=1$, $w_2 = \varepsilon$, $|w_2| = 0 < 1$).
- $aa \in L$ (так как $n=1$, $w_1 = a$, $|w_1| = 1 = n$).
- $a$ является собственным префиксом $aa$.

Ещё пример: $ba \in L$ и $baa \in L$, причём $ba$ — префикс $baa$.

---

## 7. Пересечение с регулярными аппроксимациями

Для анализа множеств First и Follow, а также для построения позиционного автомата, проведём пересечение КС-грамматики с регулярными выражениями.

### 7.1. Множества FIRST и FOLLOW

Для грамматики $G$:

**FIRST:**

| Нетерминал | FIRST |
|------------|-------|
| $S$ | $\{a, b\}$ |
| $S_1$ | $\{a, b\}$ |
| $S_2$ | $\{a, b\}$ |
| $T$ | $\{a, b\}$ |
| $R$ | $\{a, b, \varepsilon\}$ |
| $Q$ | $\{a, b\}$ |
| $U$ | $\{a, \varepsilon\}$ |

Вычисление:
- $FIRST(T)$: $T \to aT a \mid bTa \mid aa \mid ba$ ⟹ $\{a, b\}$
- $FIRST(R)$: $R \to aR \mid bR \mid \varepsilon$ ⟹ $\{a, b, \varepsilon\}$
- $FIRST(Q)$: $Q \to aQ \mid bQ \mid a$ ⟹ $\{a, b\}$
- $FIRST(U)$: $U \to aUa \mid aUb \mid \varepsilon$ ⟹ $\{a, \varepsilon\}$
- $FIRST(S_1) = FIRST(TR) = FIRST(T) = \{a, b\}$
- $FIRST(S_2) = FIRST(QU) = FIRST(Q) = \{a, b\}$
- $FIRST(S) = FIRST(S_1) \cup FIRST(S_2) = \{a, b\}$

**FOLLOW:**

| Нетерминал | FOLLOW |
|------------|--------|
| $S$ | $\{\$\}$ |
| $S_1$ | $\{\$\}$ |
| $S_2$ | $\{\$\}$ |
| $T$ | $\{a\}$ (из правил $T \to aTa$, $T \to bTa$) $\cup\ FIRST(R) \setminus \{\varepsilon\}\ \cup\ FOLLOW(S_1)$ = $\{a, b, \$\}$ |
| $R$ | $FOLLOW(S_1) = \{\$\}$ |
| $Q$ | $FIRST(U) \setminus \{\varepsilon\} \cup FOLLOW(S_2)$ = $\{a, \$\}$ |
| $U$ | $\{a, b\} \cup FOLLOW(S_2)$ = $\{a, b, \$\}$ |

Вычисление FOLLOW:
- $S \to S_1 \mid S_2$: $FOLLOW(S_1) \supseteq FOLLOW(S)$, $FOLLOW(S_2) \supseteq FOLLOW(S)$
- $S_1 \to TR$: $FOLLOW(T) \supseteq FIRST(R) \setminus \{\varepsilon\} = \{a,b\}$. Так как $\varepsilon \in FIRST(R)$: $FOLLOW(T) \supseteq FOLLOW(S_1) = \{\$\}$. Итого $FOLLOW(T) = \{a, b, \$\}$.
- $S_1 \to TR$: $FOLLOW(R) \supseteq FOLLOW(S_1) = \{\$\}$.
- $S_2 \to QU$: $FOLLOW(Q) \supseteq FIRST(U) \setminus \{\varepsilon\} = \{a\}$. Так как $\varepsilon \in FIRST(U)$: $FOLLOW(Q) \supseteq FOLLOW(S_2) = \{\$\}$. Итого $FOLLOW(Q) = \{a, \$\}$.
- $S_2 \to QU$: $FOLLOW(U) \supseteq FOLLOW(S_2) = \{\$\}$.
- $U \to aUa \mid aUb$: $FOLLOW(U) \supseteq \{a, b\}$. Итого $FOLLOW(U) = \{a, b, \$\}$.
- $T \to aTa \mid bTa$: $FOLLOW(T) \supseteq \{a\}$ (уже включено).

### 7.2. Конфликты — не LL(1)

Проверим условия LL(1) для каждого нетерминала:

**Для $S$:** $S \to S_1 \mid S_2$.
- $FIRST(S_1) = \{a,b\}$, $FIRST(S_2) = \{a,b\}$.
- $FIRST(S_1) \cap FIRST(S_2) = \{a,b\} \neq \emptyset$.
- **Конфликт!** Грамматика не является LL(1).

**Для $T$:** $T \to aTa \mid bTa \mid aa \mid ba$.
- $FIRST(aTa) = \{a\}$, $FIRST(bTa) = \{b\}$, $FIRST(aa) = \{a\}$, $FIRST(ba) = \{b\}$.
- $\{a\} \cap \{a\} = \{a\} \neq \emptyset$ (конфликт между $aTa$ и $aa$).
- $\{b\} \cap \{b\} = \{b\} \neq \emptyset$ (конфликт между $bTa$ и $ba$).
- **Конфликт!**

**Для $R$:** $R \to aR \mid bR \mid \varepsilon$.
- $FIRST(aR) = \{a\}$, $FIRST(bR) = \{b\}$, $FIRST(\varepsilon) = \{\varepsilon\}$.
- Попарно не пересекаются. Также $FOLLOW(R) = \{\$\}$, и $\{a\} \cap \{\$\} = \emptyset$, $\{b\} \cap \{\$\} = \emptyset$.
- **Нет конфликта** для $R$.

**Для $Q$:** $Q \to aQ \mid bQ \mid a$.
- $FIRST(aQ) = \{a\}$, $FIRST(bQ) = \{b\}$, $FIRST(a) = \{a\}$.
- $\{a\} \cap \{a\} = \{a\} \neq \emptyset$.
- **Конфликт!**

**Для $U$:** $U \to aUa \mid aUb \mid \varepsilon$.
- $FIRST(aUa) = \{a\}$, $FIRST(aUb) = \{a\}$, $FIRST(\varepsilon) = \{\varepsilon\}$.
- $\{a\} \cap \{a\} = \{a\} \neq \emptyset$.
- **Конфликт!**

> **Вывод:** Грамматика **не является LL(1)** (и, более того, язык $L$ не является LL(k) ни для какого $k$, поскольку $L$ — не DCFL, а все LL(k)-языки являются DCFL).

### 7.3. Построение LL(1)-автомата и LR(0)-автомата — формальная процедура

Так как язык **не DCFL**, ни LL(k)-анализатор, ни LR(k)-анализатор для него не существует. Тем не менее, можно формально построить конечные автоматы для множеств пунктов (items) и продемонстрировать наличие конфликтов.

#### LL(1)-автомат

LL(1)-таблица разбора для нетерминала $S$ при входном символе $a$:

| | $a$ | $b$ | $\$$ |
|---|-----|-----|------|
| $S$ | $S \to S_1$ **или** $S \to S_2$ (конфликт) | $S \to S_1$ **или** $S \to S_2$ (конфликт) | — |

Множественные записи в ячейках подтверждают, что таблица неоднозначна.

#### LR(0)-автомат (набросок)

Начальный пункт: $S' \to \cdot S$.

Замыкание: $S' \to \cdot S$, $S \to \cdot S_1$, $S \to \cdot S_2$, $S_1 \to \cdot TR$, $S_2 \to \cdot QU$, $T \to \cdot aTa$, $T \to \cdot bTa$, $T \to \cdot aa$, $T \to \cdot ba$, $Q \to \cdot aQ$, $Q \to \cdot bQ$, $Q \to \cdot a$.

При переходе по символу $a$ попадаем в состояние, содержащее:
$T \to a \cdot Ta$, $T \to a \cdot a$, $Q \to a \cdot Q$, $Q \to a \cdot$ (свёртка!)

Здесь $Q \to a \cdot$ — пункт свёртки, одновременно с пунктами сдвига $T \to a \cdot Ta$ и $Q \to a \cdot Q$. Это **конфликт сдвиг/свёртка** в LR(0), подтверждающий невозможность детерминированного анализа.

---

## 8. Автоматическое тестирование

Для проверки эквивалентности построенных конструкций проведём тестирование: сравним «наивный» распознаватель (перебор всех разбиений) с грамматикой.

### 8.1. Наивный распознаватель

```python
def in_language_naive(s):
    """Проверяет принадлежность строки s языку L перебором."""
    m = len(s)
    for i in range(m):           # позиция начала блока a^n
        for n in range(1, m - i + 1):  # длина блока
            # Проверяем, что s[i:i+n] — все 'a'
            if all(c == 'a' for c in s[i:i+n]):
                w1_len = i
                w2_len = m - i - n
                if w1_len == n or w2_len < n:
                    return True
    return False
```

### 8.2. Распознаватель по грамматике (CYK)

Для проверки грамматики используем алгоритм CYK (после приведения грамматики к нормальной форме Хомского) или алгоритм Эрли.

### 8.3. Тестовые примеры

| Строка | Ожидание | Наивный | Обоснование |
|--------|----------|---------|-------------|
| $\varepsilon$ | - | - | Нет разложения с $n \geq 1$ |
| $a$ | + | + | $n=1, w_2=\varepsilon, 0<1$ |
| $b$ | - | - | Нет букв $a$ |
| $aa$ | + | + | $n=1, w_1=a, \|w_1\|=1$ |
| $ab$ | - | - | $n=1, i=0$: $\|w_1\|=0\neq 1, \|w_2\|=1\not<1$ |
| $ba$ | + | + | $n=1, w_1=b, \|w_1\|=1$ |
| $bb$ | - | - | Нет букв $a$ |
| $aab$ | + | + | $n=1, w_1=a, \|w_1\|=1$ |
| $abb$ | - | - | $n=1, i=0$: $0\neq 1, 2\not<1$ |
| $bba$ | + | + | $n=1, w_2=\varepsilon, 0<1$ |
| $abab$ | - | - | Поз. 1 = $b$; все блоки не удовлетворяют |
| $abba$ | + | + | Последняя $a$: $n=1, \|w_2\|=0<1$ |
| $aabb$ | + | + | $n=1, w_1=a, \|w_1\|=1$ |
| $bab$ | + | + | $n=1, w_1=b, \|w_1\|=1$ |
| $bbab$ | - | - | Поз. 1 = $b$; блок $a$ на поз. 2: $\|w_1\|=2\neq 1$, $\|w_2\|=1\geq 1$ |
| $bbabb$ | - | - | Поз. 1 = $b$; блок $a$ на поз. 2: $\|w_1\|=2\neq 1$, $\|w_2\|=2\geq 1$ |

### 8.4. Результаты автоматического тестирования

Полный перебор всех строк длины $\leq 7$ (255 строк) подтверждает корректность грамматики и разбиения $L = L_1 \cup L_2$:

| Длина | В $L$ | Всего | Доля |
|-------|-------|-------|------|
| 0 | 0 | 1 | 0.0% |
| 1 | 1 | 2 | 50.0% |
| 2 | 2 | 4 | 50.0% |
| 3 | 6 | 8 | 75.0% |
| 4 | 12 | 16 | 75.0% |
| 5 | 26 | 32 | 81.2% |
| 6 | 54 | 64 | 84.4% |
| 7 | 110 | 128 | 85.9% |

Расхождений между наивным распознавателем, грамматикой и разбиением $L_1 \cup L_2$ — **0**.

Строки вне $L$ при малых длинах: $\varepsilon$, $b$, $ab$, $bb$, $abb$, $bbb$, $abab$, $abbb$, $bbab$, $bbbb$, ...

### 8.5. Код тестирования

```python
import itertools

def in_language(s):
    """Эталонная проверка принадлежности к L."""
    m = len(s)
    if not all(c in 'ab' for c in s):
        return False
    for i in range(m):
        for n in range(1, m - i + 1):
            if all(s[j] == 'a' for j in range(i, i + n)):
                w1_len = i
                w2_len = m - i - n
                if w1_len == n or w2_len < n:
                    return True
    return False

# Генерируем все строки длины до 7 и проверяем
for length in range(0, 8):
    for bits in itertools.product('ab', repeat=length):
        s = ''.join(bits)
        result = in_language(s)
        # Здесь можно сравнить с CYK-распознавателем
        # для проверки корректности грамматики

# Вывод статистики
for length in range(0, 8):
    total = 2 ** length
    count = sum(1 for bits in itertools.product('ab', repeat=length)
                if in_language(''.join(bits)))
    print(f"Длина {length}: {count}/{total} строк в L")
```

---

## 9. Итоговые выводы

| Свойство | Результат |
|----------|-----------|
| Тип языка | Контекстно-свободный (КС / CFL) |
| Детерминированность | **Недетерминированный** КС-язык (не DCFL) |
| Беспрефиксность | **Не беспрефиксный** |
| LL-свойство | **Не LL(k)** ни для какого $k$ (следствие не-DCFL) |
| Тип автомата | Недетерминированный МП-автомат (НМПА / NPDA) |
| Существенность недетерминизма | Да: выбор стратегии и границы блока $a^n$ |

Язык $L$ является **собственно недетерминированным** контекстно-свободным языком: он распознаётся НМПА, но не ДМПА. Доказательство основано на том, что дополнение $\overline{L}$ не является контекстно-свободным (через лемму о накачке для КС-языков).
