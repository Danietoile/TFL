# Лабораторная работа 4

## Регулярное выражение и исправление опечатки

В условии выражение напечатано с нарушенным балансом скобок. Так как в нём используются ссылки `\2` и `\3`, естественно предполагается наличие **трёх независимых** захватывающих групп. Далее используем синтаксически корректную версию, сохраняющую структуру ссылок:

```
^((?:a|b)+)((?:a|b)+)((?:a|b)+)\2\3(\1\1)+$
```

Здесь:
- `^` и `$` — якоря начала/конца строки;
- `((?:a|b)+)` — непустая подстрока над `{a,b}`;
- `\2\3` — повтор подстрок групп 2 и 3;
- `(\1\1)+` — один или более повторов конкатенации `\1\1`.

---

## Язык, задаваемый выражением

Обозначим: `\1 = w`, `\2 = x`, `\3 = y`, где `w, x, y ∈ {a,b}⁺`.

Тогда выражение задаёт ровно строки вида:
- сначала `wxy`;
- затем из-за `\2\3` снова `xy`;
- затем из-за `(\1\1)+` суффикс вида `(ww)ⁿ`, где `n ≥ 1`.

То есть язык равен:

**L = { wxyxy(ww)ⁿ | w, x, y ∈ {a,b}⁺, n ≥ 1 }**

---

## Доказательство неконтекстно-свободности 

Покажем, что язык L **не является контекстно-свободным**.

### 3.1 Формулировка леммы Огдена

Если язык L контекстно-свободен, то существует число P такое, что для любого слова s ∈ L и любого выбора не менее P **отмеченных позиций** в слове s существует разложение

**s = u v x y z**

удовлетворяющее условиям:

1. подстроки v и y содержат хотя бы одну отмеченную позицию;
2. |vxy| ≤ P;
3. для всех t ≥ 0 слово u vᵗ x yᵗ z ∈ L.

### Выбор слова и отмеченных позиций

Предположим противное: язык L контекстно-свободен, и пусть P — константа из леммы Огдена. Положим N = P + 1 и рассмотрим слово

**s = aᴺ b⁴ a²ᴺ**

Покажем, что s ∈ L: возьмём w = aᴺ, x = b, y = b, n = 1. Тогда

wxyxy(ww)¹ = aᴺ · bbbb · a²ᴺ = aᴺ b⁴ a²ᴺ = s

Теперь отметим **все N позиций** первой копии w в суффиксе ww = a²ᴺ, то есть отметим первые N букв `a` в хвосте a²ᴺ. Их ровно N = P + 1 ≥ P, значит условие леммы выполнено.

### Применение леммы и накачка

По лемме существует разложение s = uvxyz такое, что v и y содержат отмеченные позиции, а также |vxy| ≤ P.

Все отмеченные позиции расположены **строго внутри** первой из двух копий aᴺ в хвосте a²ᴺ = aᴺaᴺ. Так как |vxy| ≤ P < N, подслово vxy не может дотянуться до границы между двумя копиями хвоста, а значит **целиком лежит внутри** первой копии aᴺ в хвосте.

Следовательно, при накачке меняется только количество букв `a` внутри первой копии хвоста, а префикс aᴺb⁴ и вторая копия хвоста aᴺ остаются неизменными.

Рассмотрим t = 0 и слово

**s₀ = u v⁰ x y⁰ z = u x z**

Так как v и y непусты (они содержат отмеченные позиции), длина хвоста уменьшается на d = |v| + |y|, где 1 ≤ d ≤ |vxy| ≤ P. Значит слово s₀ имеет вид

**s₀ = aᴺ b⁴ a²ᴺ⁻ᵈ**

### Почему s₀ ∉ L при любом разбиении

Предположим, что s₀ ∈ L. Тогда существует разбиение

s₀ = w′x′y′x′y′(w′w′)ⁿ′, где w′, x′, y′ ∈ {a,b}⁺, n′ ≥ 1

Но в слове s₀ **все буквы `b`** образуют единственный блок b⁴, и других `b` в слове нет.

Отсюда следует:

- Подстрока (w′w′)ⁿ′ не может содержать `b` (иначе в s₀ были бы `b` после блока b⁴), значит w′ состоит только из `a`, то есть w′ = aᵐ для некоторого m ≥ 1.

- Подстрока x′y′x′y′ должна дать ровно b⁴ и не содержать `a`. Значит x′ и y′ состоят только из `b`. Так как длина x′y′x′y′ равна 4, получаем единственную возможность: **x′ = b, y′ = b**.

- Тогда w′ — это весь начальный блок `a` перед первой буквой `b`. В слове s₀ перед b⁴ стоит ровно aᴺ, значит **w′ = aᴺ**.

Следовательно, хвост после b⁴ обязан иметь длину, кратную |ww| = 2N:

(w′w′)ⁿ′ = (aᴺaᴺ)ⁿ′ = a²ᴺⁿ′

Но в s₀ длина хвоста равна 2N − d, где 1 ≤ d ≤ P < N, то есть 2N − d не кратно 2N и даже строго меньше 2N. **Противоречие.**

Значит s₀ ∉ L, что противоречит лемме Огдена (пункт 3).

### Вывод

Противоречие показывает, что исходное предположение неверно.

**Следовательно, язык L не является контекстно-свободным.**

## 4. Наивный парсер (рекурсивный разбор с возвратами)

### 4.1. Идея

Парсер перебирает разбиение строки на `w`, `x`, `y` (все непустые) и затем проверяет:

- что после `wxy` действительно стоит `xy`;
- что остаток строки является `(ww)^n` при некотором `n ≥ 1`.

Это реализовано как рекурсивный поиск с возвратами: если выбранные границы не подошли, пробуем другие.

Зацикливания нет, потому что позиция в строке при выборе границ всегда увеличивается.

### 4.2. Оценка сложности (сверху)

В худшем случае перебирается:
- $O(n)$ вариантов длины `w`,
- $O(n)$ вариантов длины `x`,
- $O(n)$ вариантов длины `y`,
- и проверка хвоста занимает $O(n)$.

Итого верхняя оценка:

```math
T_{\text{naive}}(n)=O(n^4).
```

---

## 5. Оптимизированный парсер

### 5.1. Идея оптимизации

Заметим, что средняя часть `xyxy` — это **квадрат** строки `xy`, то есть:

```math
xyxy = (xy)(xy).
```

Поэтому вместо перебора отдельно `x` и `y` можно проверять только условие:
- подстрока между `w` и хвостом имеет чётную длину ≥ 4;
- её первая половина равна второй.

Также хвост должен быть повторением `ww`.

Это уменьшает объём перебора и даёт сильный выигрыш по времени на практике.

### 5.2. Оценка сложности (сверху)

Перебор длины `w` - $O(n)$.
Для фиксированного `w` рассматриваются возможные позиции начала хвоста с шагом `2|w|`.
На каждом кандидате выполняется линейная проверка равенства половинок и проверка повторения `ww`.

Грубая верхняя оценка:

```math
T_{\text{fast}}(n)=O(n^3).
```

---

## 6. Фазз-тестирование и графики скорости

Проверяем эквивалентность парсеров на случайных словах и строим два графика времени:
- для слов, принадлежащих языку;
- для слов, не принадлежащих языку.

Код в fazz test.py:
1) реализует оба парсера
2) делает фазз-тест
3) строит два графика 

    Фазз-тест пройден: парсеры эквивалентны на случайных тестах.


    
![png](output_3_1.png)
    


    
![png](output_3_2.png)
