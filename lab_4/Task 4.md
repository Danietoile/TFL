# Лабораторная работа 4

## Регулярное выражение и исправление опечатки

В исходной записи выражения в условии нарушен баланс скобок. Так как в выражении используются ссылки `\2` и `\3`, естественно предполагается наличие трёх независимых захватывающих групп. Для дальнейшего анализа используется синтаксически корректная версия, сохраняющая структуру ссылок: `^((?:a|b)+)((?:a|b)+)((?:a|b)+)\2\3(\1\1)+$`

Далее расшифруем выражение по захватывающим группам.

Обозначим:
- \(w\) — подстрока, захваченная группой \1, то есть \(w \in \{a,b\}^+\);
- \(x\) — подстрока, захваченная группой \2, то есть \(x \in \{a,b\}^+\);
- \(y\) — подстрока, захваченная группой \3, то есть \(y \in \{a,b\}^+\).

Тогда выражение имеет структуру:

- сначала считывается \(wxy\);
- затем фрагмент `\2\3` требует повторить \(xy\) буквально;
- затем фрагмент `(\1\1)+` требует один или более раз повторить \(ww\);
- якоря `^` и `$` фиксируют, что вся строка целиком имеет именно этот вид.

Следовательно, язык \(L\), задаваемый этим выражением, равен: `L = { w x y x y (w w)^n | w,x,y ∈ {a,b}^+, n ≥ 1 }`.

### Доказательство неконтекстно-свободности 

Покажем, что язык

L = { wxyxy(ww)^n | w,x,y ∈ Σ^+, n ≥ 1 },   Σ = {a,b}

не является контекстно-свободным.

---

#### Предположение

Предположим противное: L — контекстно-свободный язык.
Пусть P — константа из леммы Огдена.

---

#### Выбор слова и отмеченных позиций

Рассмотрим слово s ∈ L при x = y = a, n = 1 и

w = b^{P+1} a^{P+1}.

Тогда

s = w · a a a a · w_left · w_right,

где w_left и w_right — две подряд идущие копии w в суффиксе.

Отметим все позиции, принадлежащие блоку w_left.
Количество отмеченных позиций равно |w| = 2P+2 > P.

---

#### Применение леммы Огдена

По лемме существует разложение

s = u v w₀ x z

такое что:

1) подстроки v и x содержат хотя бы одну отмеченную позицию;

2) подстрока v w₀ x содержит не более P отмеченных позиций;

3) для любого t ≥ 0 слово  
   s_t = u v^t w₀ x^t z  
   принадлежит L.

---

#### Анализ расположения накачки

Все отмеченные позиции находятся исключительно внутри блока w_left.

Следовательно, подстроки v и x обязательно затрагивают w_left.

Кроме того, длина блока w_left равна 2P+2,
а подстрока v w₀ x содержит не более P отмеченных позиций.
Значит v w₀ x не может охватить весь блок w_left,
то есть накачка изменяет только часть w_left.

Теперь важно отметить следующее.

Расстояние между началом блока w_left и началом блока w_right
равно |w| = 2P+2 > P.

Так как подстрока v w₀ x содержит не более P отмеченных позиций
и лежит внутри области отмеченных символов,
она физически не может одновременно затронуть
соответствующие позиции в блоках w_left и w_right.

Следовательно, накачка изменяет только блок w_left,
а блок w_right остаётся неизменным.

---

#### Накачка при t = 0

Рассмотрим слово

s₀ = u v^0 w₀ x^0 z.

В нём блок w_left изменился,
а блок w_right остался равным исходному w.

Следовательно, две подряд идущие копии в суффиксе
больше не совпадают.

Однако любое слово из L должно оканчиваться на (WW)^n,
то есть на две одинаковые подряд идущие копии некоторого блока W.

Получаем противоречие: s₀ ∉ L.

---

#### Заключение

Противоречие с леммой Огдена.
Следовательно, язык L не является контекстно-свободным.

## 4. Наивный парсер (рекурсивный разбор с возвратами)

### 4.1. Идея

Парсер перебирает разбиение строки на `w`, `x`, `y` (все непустые) и затем проверяет:

- что после `wxy` действительно стоит `xy`;
- что остаток строки является `(ww)^n` при некотором `n ≥ 1`.

Это реализовано как рекурсивный поиск с возвратами: если выбранные границы не подошли, пробуем другие.

Зацикливания нет, потому что позиция в строке при выборе границ всегда увеличивается.

### 4.2. Оценка сложности (сверху)

В худшем случае перебирается:
- $O(n)$ вариантов длины `w`,
- $O(n)$ вариантов длины `x`,
- $O(n)$ вариантов длины `y`,
- и проверка хвоста занимает $O(n)$.

Итого верхняя оценка:
$$
T_{\text{naive}}(n)=O(n^4).
$$

---

## 5. Оптимизированный парсер

### 5.1. Идея оптимизации

Заметим, что средняя часть `xyxy` — это **квадрат** строки `xy`, то есть:

$$
xyxy = (xy)(xy).
$$

Поэтому вместо перебора отдельно `x` и `y` можно проверять только условие:
- подстрока между `w` и хвостом имеет чётную длину ≥ 4;
- её первая половина равна второй.

Также хвост должен быть повторением `ww`.

Это уменьшает объём перебора и даёт сильный выигрыш по времени на практике.

### 5.2. Оценка сложности (сверху)

Перебор длины `w` - $O(n)$.
Для фиксированного `w` рассматриваются возможные позиции начала хвоста с шагом `2|w|`.
На каждом кандидате выполняется линейная проверка равенства половинок и проверка повторения `ww`.

Грубая верхняя оценка:
$$
T_{\text{fast}}(n)=O(n^3).
$$

---

## 6. Фазз-тестирование и графики скорости

Проверяем эквивалентность парсеров на случайных словах и строим два графика времени:
- для слов, принадлежащих языку;
- для слов, не принадлежащих языку.

Код в fazz test.py:
1) реализует оба парсера
2) делает фазз-тест
3) строит два графика 

    Фазз-тест пройден: парсеры эквивалентны на случайных тестах.



    
![png](output_3_1.png)
    



    
![png](output_3_2.png)